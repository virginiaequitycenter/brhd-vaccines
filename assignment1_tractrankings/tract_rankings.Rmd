---
title: "Tract Score Composite Development"
author: "Sam Powers"
date: "3/18/2021"
#output: html_document
header-includes:
 - \usepackage[default]{sourcesanspro}
 - \usepackage[T1]{fontenc}
mainfont: SourceSansPro
fontsize: 11pt
output: 
  html_document:
    df_print: kable
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(extrafont)
library(psych)
loadfonts() ## Load in the fonts I want to use

options(scipen = 6, digits = 4) # I prefer to view outputs in non-scientific notation
select <- dplyr::select
```


## Implementation Plan

### 1. Generate an index and ranking using just the poverty, race and life expectancy using BRHD values 

```{r}
## read in data:

tract_dimensions <- read_csv("../data/tract_dimensions.csv")

describe(tract_dimensions)
# little variance in Indigenous pop

# Step 1: Poverty,  Race,  BRHD LE 
step1_dat <- 
tract_dimensions %>%
  select(blackE, indigE, ltnxE, povrateE, lifeexpBRHD)

step1_eig <- eigen(cor(step1_dat))$values
step1_eig/sum(step1_eig)

scree(step1_dat) ## there might be two factors in here
alpha(step1_dat, check.keys = TRUE)

fa(step1_dat, nfactors=1, rotate="promax", fm="ml", SMC=TRUE)
# Latinx shares little variance with other factors 
# The RMSEA is good though

fa(step1_dat, nfactors=2, rotate="promax", fm="ml", SMC=TRUE)
# this is clearly overfit. 
```



### Step 2: Compare against the life expectancy values from USASLEEP 

```{r}
step2_dat <- 
  tract_dimensions %>%
  select(blackE, indigE, ltnxE, povrateE, lifeexpCDC) %>%
  filter(!is.na(lifeexpCDC)) # too impatint to try FIML. Going to use complete cases to develop

step2_eig <- eigen(cor(step2_dat))$values
step2_eig/sum(step2_eig)

scree(step2_dat) ## there might be two factors in here
alpha(step2_dat, check.keys = TRUE)

fa(step2_dat, nfactors=1, rotate="promax", fm="ml", SMC=TRUE)
# Indigenous really is not providing us with much variance. 
# The RMSEA is fine though

fa(step2_dat, nfactors=2, rotate="promax", fm="ml", SMC=TRUE)
# this is clearly overfit. 

# I would say there is a solid argument that these are all part of one factor
```

### Step 3: Incorporate health outcomes

Exploration of health outcomes

```{r}
# look at health outcomes 
outcomes <- 
tract_dimensions %>%
  select(contains("outcome"))

outcome_eig <- eigen(cor(outcomes))$values
outcome_eig/sum(outcome_eig) # 71.8% of the variance is in the first component. This should be fine to load together

scree(outcomes) ## there might be two factors in here. also there are some weird pattens. Factor analysis is out. 
alpha(outcomes) ## This alpha is high. I think we definitely can condense these. 

# maybe make a principal component out of them 
pca.outcomes <-
principal(outcomes, nfactors=1, rotate="none", scores=TRUE) # This gets 72% of the variance. Cancer is not high, but its there. 
pca.outcomes

principal(outcomes, nfactors=2, rotate="none", scores=TRUE) # This is decent but there are crossed loadings [smoking & cancer]


# Maybe we assume independence between the diseases and look at probability of having at least one co-morbidity?
# We know they aren't independent within persons, but this is definitely conservative?

prob_atleast_one <-
tract_dimensions %>%
  select(GEOID, contains("outcome")) %>%
  mutate(across(contains("outcome"), ~1 - .x/100)) %>% # Probability of not having the comorbidity
  gather(outcome, prob_not, -GEOID) %>%
  group_by(GEOID) %>% 
  summarize(prob_none = prod(prob_not)) %>%            # Product of independent probabilities = prob(no comorbidities)
  mutate(perc_atleast_one = (1 - prob_none) *100)      # 1 - P(none) = p(1+)
  
combine_outcomes <- 
tibble(
GEOID = 
tract_dimensions$GEOID,
pca = pca.outcomes$scores[,1]
) %>%
  left_join(prob_atleast_one)

# they describe very similar phenomena
cor(combine_outcomes$perc_atleast_one, combine_outcomes$pca,  method = "spearman") # 0.9482
normed_outcomes <-
combine_outcomes %>%
  mutate(
    across(c("pca", "perc_atleast_one"),
           ~(.x - min(.x))/ (max(.x) - min(.x))
           )
  ) %>%
  select(GEOID, pca, perc_atleast_one) 

cor(normed_outcomes$pca, normed_outcomes$perc_atleast_one, method = "spearman") # 0.9498

normed_outcomes %>%
arrange(pca) 
# They generally move in the same direction but they do not rank counties in exactly the same way. 
# There is a weird trend of decreasing perc_atleast_one until a point then it jumps and then decreases again 

var(normed_outcomes$pca)
mean(normed_outcomes$pca) # this is centered high

var(normed_outcomes$perc_atleast_one) # This has more variance
mean(normed_outcomes$perc_atleast_one) # This is centered pretty well

```

### 4: Create final index

```{r}
normed_metrics <- 
tract_dimensions %>%
  select(GEOID,
         blackE,
         # indigE,  removing indigenous
         ltnxE,
         povrateE,
         lifeexpBRHD  # this one needs to be reversed
         ) %>%
         mutate(across(-GEOID,
                       ~ (.x - min(.x)) / (max(.x) - min(.x)))) %>%
           mutate(lifeexpBRHD = 1 - lifeexpBRHD) %>%
  left_join(
    normed_outcomes %>%
      select(GEOID, 
             health_outcomes = perc_atleast_one
             )
  )


principal(normed_metrics[,-1], nfactors=2, rotate="none", scores=TRUE)
# there is definitely a black, life expectancy, & health outcomes dimension and then a latinx & poverty rate w/ good health outcomes 
# dimension that seem perpendicular 
# But based on theory we want to weight those all the same, so I think we are probably good to go to just add them up together

final_rankings  <- 
normed_metrics %>%
  mutate(overall = blackE + ltnxE + povrateE + lifeexpBRHD + health_outcomes,
         overall_no_outcomes = blackE + ltnxE + povrateE + lifeexpBRHD) %>%
  arrange(
    desc(overall_no_outcomes)
  ) %>%
  mutate(rank_no_outcomes = 1:n()) %>%
  arrange(
    desc(overall)
  ) %>%
  mutate(rank_outcomes = 1:n())  

max(final_rankings$overall) # 3.34
min(final_rankings$overall) # 0.448
# not quite the variance we would hope for, but this works! 
(max(final_rankings$overall) - min(final_rankings$overall))/5  # uses 0.5784 of its possible range


max(final_rankings$overall_no_outcomes) # 2.603
min(final_rankings$overall_no_outcomes) # 0.07239
(max(final_rankings$overall_no_outcomes)  - min(final_rankings$overall_no_outcomes))/4 # uses 0.6328 of its possible range

cor(final_rankings$overall, final_rankings$overall_no_outcomes, method = "spearman") 
# They correlate at 0.9239
```
